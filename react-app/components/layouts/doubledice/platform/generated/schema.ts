// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Category extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Category entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Category must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Category", id.toString(), this);
    }
  }

  static load(id: string): Category | null {
    return changetype<Category | null>(store.get("Category", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get slug(): string {
    let value = this.get("slug");
    return value!.toString();
  }

  set slug(value: string) {
    this.set("slug", Value.fromString(value));
  }

  get subcategories(): Array<string> {
    let value = this.get("subcategories");
    return value!.toStringArray();
  }

  set subcategories(value: Array<string>) {
    this.set("subcategories", Value.fromStringArray(value));
  }

  get virtualFloors(): Array<string> {
    let value = this.get("virtualFloors");
    return value!.toStringArray();
  }

  set virtualFloors(value: Array<string>) {
    this.set("virtualFloors", Value.fromStringArray(value));
  }
}

export class Subcategory extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Subcategory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Subcategory must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Subcategory", id.toString(), this);
    }
  }

  static load(id: string): Subcategory | null {
    return changetype<Subcategory | null>(store.get("Subcategory", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get category(): string {
    let value = this.get("category");
    return value!.toString();
  }

  set category(value: string) {
    this.set("category", Value.fromString(value));
  }

  get virtualFloors(): Array<string> {
    let value = this.get("virtualFloors");
    return value!.toStringArray();
  }

  set virtualFloors(value: Array<string>) {
    this.set("virtualFloors", Value.fromStringArray(value));
  }

  get subid(): string {
    let value = this.get("subid");
    return value!.toString();
  }

  set subid(value: string) {
    this.set("subid", Value.fromString(value));
  }

  get slug(): string {
    let value = this.get("slug");
    return value!.toString();
  }

  set slug(value: string) {
    this.set("slug", Value.fromString(value));
  }
}

export class VirtualFloor extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VirtualFloor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VirtualFloor must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VirtualFloor", id.toString(), this);
    }
  }

  static load(id: string): VirtualFloor | null {
    return changetype<VirtualFloor | null>(store.get("VirtualFloor", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get intId(): BigInt {
    let value = this.get("intId");
    return value!.toBigInt();
  }

  set intId(value: BigInt) {
    this.set("intId", Value.fromBigInt(value));
  }

  get creator(): string {
    let value = this.get("creator");
    return value!.toString();
  }

  set creator(value: string) {
    this.set("creator", Value.fromString(value));
  }

  get owner(): string {
    let value = this.get("owner");
    return value!.toString();
  }

  set owner(value: string) {
    this.set("owner", Value.fromString(value));
  }

  get subcategory(): string {
    let value = this.get("subcategory");
    return value!.toString();
  }

  set subcategory(value: string) {
    this.set("subcategory", Value.fromString(value));
  }

  get category(): string {
    let value = this.get("category");
    return value!.toString();
  }

  set category(value: string) {
    this.set("category", Value.fromString(value));
  }

  get challenger(): string | null {
    let value = this.get("challenger");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set challenger(value: string | null) {
    if (!value) {
      this.unset("challenger");
    } else {
      this.set("challenger", Value.fromString(<string>value));
    }
  }

  get userVirtualFloors(): Array<string> {
    let value = this.get("userVirtualFloors");
    return value!.toStringArray();
  }

  set userVirtualFloors(value: Array<string>) {
    this.set("userVirtualFloors", Value.fromStringArray(value));
  }

  get outcomes(): Array<string> {
    let value = this.get("outcomes");
    return value!.toStringArray();
  }

  set outcomes(value: Array<string>) {
    this.set("outcomes", Value.fromStringArray(value));
  }

  get opponents(): Array<string> {
    let value = this.get("opponents");
    return value!.toStringArray();
  }

  set opponents(value: Array<string>) {
    this.set("opponents", Value.fromStringArray(value));
  }

  get resultSources(): Array<string> {
    let value = this.get("resultSources");
    return value!.toStringArray();
  }

  set resultSources(value: Array<string>) {
    this.set("resultSources", Value.fromStringArray(value));
  }

  get paymentToken(): string {
    let value = this.get("paymentToken");
    return value!.toString();
  }

  set paymentToken(value: string) {
    this.set("paymentToken", Value.fromString(value));
  }

  get betaOpen(): BigDecimal {
    let value = this.get("betaOpen");
    return value!.toBigDecimal();
  }

  set betaOpen(value: BigDecimal) {
    this.set("betaOpen", Value.fromBigDecimal(value));
  }

  get totalFeeRate(): BigDecimal {
    let value = this.get("totalFeeRate");
    return value!.toBigDecimal();
  }

  set totalFeeRate(value: BigDecimal) {
    this.set("totalFeeRate", Value.fromBigDecimal(value));
  }

  get creationFeeRate(): BigDecimal {
    let value = this.get("creationFeeRate");
    return value!.toBigDecimal();
  }

  set creationFeeRate(value: BigDecimal) {
    this.set("creationFeeRate", Value.fromBigDecimal(value));
  }

  get protocolFeeRate(): BigDecimal {
    let value = this.get("protocolFeeRate");
    return value!.toBigDecimal();
  }

  set protocolFeeRate(value: BigDecimal) {
    this.set("protocolFeeRate", Value.fromBigDecimal(value));
  }

  get platformFeeRate(): BigDecimal {
    let value = this.get("platformFeeRate");
    return value!.toBigDecimal();
  }

  set platformFeeRate(value: BigDecimal) {
    this.set("platformFeeRate", Value.fromBigDecimal(value));
  }

  get creationTxHash(): Bytes {
    let value = this.get("creationTxHash");
    return value!.toBytes();
  }

  set creationTxHash(value: Bytes) {
    this.set("creationTxHash", Value.fromBytes(value));
  }

  get creationTxTimestamp(): BigInt {
    let value = this.get("creationTxTimestamp");
    return value!.toBigInt();
  }

  set creationTxTimestamp(value: BigInt) {
    this.set("creationTxTimestamp", Value.fromBigInt(value));
  }

  get tCreated(): BigInt {
    let value = this.get("tCreated");
    return value!.toBigInt();
  }

  set tCreated(value: BigInt) {
    this.set("tCreated", Value.fromBigInt(value));
  }

  get tOpen(): BigInt {
    let value = this.get("tOpen");
    return value!.toBigInt();
  }

  set tOpen(value: BigInt) {
    this.set("tOpen", Value.fromBigInt(value));
  }

  get tClose(): BigInt {
    let value = this.get("tClose");
    return value!.toBigInt();
  }

  set tClose(value: BigInt) {
    this.set("tClose", Value.fromBigInt(value));
  }

  get tResolve(): BigInt {
    let value = this.get("tResolve");
    return value!.toBigInt();
  }

  set tResolve(value: BigInt) {
    this.set("tResolve", Value.fromBigInt(value));
  }

  get bonusAmount(): BigDecimal {
    let value = this.get("bonusAmount");
    return value!.toBigDecimal();
  }

  set bonusAmount(value: BigDecimal) {
    this.set("bonusAmount", Value.fromBigDecimal(value));
  }

  get optionalMinCommitmentAmount(): BigDecimal | null {
    let value = this.get("optionalMinCommitmentAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set optionalMinCommitmentAmount(value: BigDecimal | null) {
    if (!value) {
      this.unset("optionalMinCommitmentAmount");
    } else {
      this.set(
        "optionalMinCommitmentAmount",
        Value.fromBigDecimal(<BigDecimal>value)
      );
    }
  }

  get optionalMaxCommitmentAmount(): BigDecimal | null {
    let value = this.get("optionalMaxCommitmentAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set optionalMaxCommitmentAmount(value: BigDecimal | null) {
    if (!value) {
      this.unset("optionalMaxCommitmentAmount");
    } else {
      this.set(
        "optionalMaxCommitmentAmount",
        Value.fromBigDecimal(<BigDecimal>value)
      );
    }
  }

  get minCommitmentAmount(): BigDecimal {
    let value = this.get("minCommitmentAmount");
    return value!.toBigDecimal();
  }

  set minCommitmentAmount(value: BigDecimal) {
    this.set("minCommitmentAmount", Value.fromBigDecimal(value));
  }

  get maxCommitmentAmount(): BigDecimal {
    let value = this.get("maxCommitmentAmount");
    return value!.toBigDecimal();
  }

  set maxCommitmentAmount(value: BigDecimal) {
    this.set("maxCommitmentAmount", Value.fromBigDecimal(value));
  }

  get resolutionOrCancellationTxHash(): Bytes | null {
    let value = this.get("resolutionOrCancellationTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set resolutionOrCancellationTxHash(value: Bytes | null) {
    if (!value) {
      this.unset("resolutionOrCancellationTxHash");
    } else {
      this.set("resolutionOrCancellationTxHash", Value.fromBytes(<Bytes>value));
    }
  }

  get resolutionOrCancellationTxTimestamp(): BigInt | null {
    let value = this.get("resolutionOrCancellationTxTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set resolutionOrCancellationTxTimestamp(value: BigInt | null) {
    if (!value) {
      this.unset("resolutionOrCancellationTxTimestamp");
    } else {
      this.set(
        "resolutionOrCancellationTxTimestamp",
        Value.fromBigInt(<BigInt>value)
      );
    }
  }

  get tResultSetMin(): BigInt {
    let value = this.get("tResultSetMin");
    return value!.toBigInt();
  }

  set tResultSetMin(value: BigInt) {
    this.set("tResultSetMin", Value.fromBigInt(value));
  }

  get tResultSetMax(): BigInt {
    let value = this.get("tResultSetMax");
    return value!.toBigInt();
  }

  set tResultSetMax(value: BigInt) {
    this.set("tResultSetMax", Value.fromBigInt(value));
  }

  get tResultChallengeMax(): BigInt | null {
    let value = this.get("tResultChallengeMax");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set tResultChallengeMax(value: BigInt | null) {
    if (!value) {
      this.unset("tResultChallengeMax");
    } else {
      this.set("tResultChallengeMax", Value.fromBigInt(<BigInt>value));
    }
  }

  get state(): string {
    let value = this.get("state");
    return value!.toString();
  }

  set state(value: string) {
    this.set("state", Value.fromString(value));
  }

  get winningOutcome(): string | null {
    let value = this.get("winningOutcome");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set winningOutcome(value: string | null) {
    if (!value) {
      this.unset("winningOutcome");
    } else {
      this.set("winningOutcome", Value.fromString(<string>value));
    }
  }

  get winnerProfits(): BigDecimal | null {
    let value = this.get("winnerProfits");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set winnerProfits(value: BigDecimal | null) {
    if (!value) {
      this.unset("winnerProfits");
    } else {
      this.set("winnerProfits", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get flaggingReason(): string | null {
    let value = this.get("flaggingReason");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set flaggingReason(value: string | null) {
    if (!value) {
      this.unset("flaggingReason");
    } else {
      this.set("flaggingReason", Value.fromString(<string>value));
    }
  }

  get resultUpdateAction(): string | null {
    let value = this.get("resultUpdateAction");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set resultUpdateAction(value: string | null) {
    if (!value) {
      this.unset("resultUpdateAction");
    } else {
      this.set("resultUpdateAction", Value.fromString(<string>value));
    }
  }

  get title(): string {
    let value = this.get("title");
    return value!.toString();
  }

  set title(value: string) {
    this.set("title", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    return value!.toString();
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get isListed(): boolean {
    let value = this.get("isListed");
    return value!.toBoolean();
  }

  set isListed(value: boolean) {
    this.set("isListed", Value.fromBoolean(value));
  }

  get discordChannelId(): string {
    let value = this.get("discordChannelId");
    return value!.toString();
  }

  set discordChannelId(value: string) {
    this.set("discordChannelId", Value.fromString(value));
  }

  get isTest(): boolean {
    let value = this.get("isTest");
    return value!.toBoolean();
  }

  set isTest(value: boolean) {
    this.set("isTest", Value.fromBoolean(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    return value!.toBigDecimal();
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get allText(): string {
    let value = this.get("allText");
    return value!.toString();
  }

  set allText(value: string) {
    this.set("allText", Value.fromString(value));
  }
}

export class Opponent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Opponent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Opponent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Opponent", id.toString(), this);
    }
  }

  static load(id: string): Opponent | null {
    return changetype<Opponent | null>(store.get("Opponent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get virtualFloor(): string {
    let value = this.get("virtualFloor");
    return value!.toString();
  }

  set virtualFloor(value: string) {
    this.set("virtualFloor", Value.fromString(value));
  }

  get title(): string {
    let value = this.get("title");
    return value!.toString();
  }

  set title(value: string) {
    this.set("title", Value.fromString(value));
  }

  get image(): string {
    let value = this.get("image");
    return value!.toString();
  }

  set image(value: string) {
    this.set("image", Value.fromString(value));
  }
}

export class ResultSource extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ResultSource entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ResultSource must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ResultSource", id.toString(), this);
    }
  }

  static load(id: string): ResultSource | null {
    return changetype<ResultSource | null>(store.get("ResultSource", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get virtualFloor(): string {
    let value = this.get("virtualFloor");
    return value!.toString();
  }

  set virtualFloor(value: string) {
    this.set("virtualFloor", Value.fromString(value));
  }

  get title(): string {
    let value = this.get("title");
    return value!.toString();
  }

  set title(value: string) {
    this.set("title", Value.fromString(value));
  }

  get url(): string {
    let value = this.get("url");
    return value!.toString();
  }

  set url(value: string) {
    this.set("url", Value.fromString(value));
  }
}

export class Outcome extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Outcome entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Outcome must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Outcome", id.toString(), this);
    }
  }

  static load(id: string): Outcome | null {
    return changetype<Outcome | null>(store.get("Outcome", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get virtualFloor(): string {
    let value = this.get("virtualFloor");
    return value!.toString();
  }

  set virtualFloor(value: string) {
    this.set("virtualFloor", Value.fromString(value));
  }

  get outcomeTimeslots(): Array<string> {
    let value = this.get("outcomeTimeslots");
    return value!.toStringArray();
  }

  set outcomeTimeslots(value: Array<string>) {
    this.set("outcomeTimeslots", Value.fromStringArray(value));
  }

  get userOutcomeTimeslots(): Array<string> {
    let value = this.get("userOutcomeTimeslots");
    return value!.toStringArray();
  }

  set userOutcomeTimeslots(value: Array<string>) {
    this.set("userOutcomeTimeslots", Value.fromStringArray(value));
  }

  get userOutcomes(): Array<string> {
    let value = this.get("userOutcomes");
    return value!.toStringArray();
  }

  set userOutcomes(value: Array<string>) {
    this.set("userOutcomes", Value.fromStringArray(value));
  }

  get title(): string {
    let value = this.get("title");
    return value!.toString();
  }

  set title(value: string) {
    this.set("title", Value.fromString(value));
  }

  get index(): i32 {
    let value = this.get("index");
    return value!.toI32();
  }

  set index(value: i32) {
    this.set("index", Value.fromI32(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    return value!.toBigDecimal();
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get totalWeightedSupply(): BigDecimal {
    let value = this.get("totalWeightedSupply");
    return value!.toBigDecimal();
  }

  set totalWeightedSupply(value: BigDecimal) {
    this.set("totalWeightedSupply", Value.fromBigDecimal(value));
  }
}

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type User must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("User", id.toString(), this);
    }
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userVirtualFloors(): Array<string> {
    let value = this.get("userVirtualFloors");
    return value!.toStringArray();
  }

  set userVirtualFloors(value: Array<string>) {
    this.set("userVirtualFloors", Value.fromStringArray(value));
  }

  get userOutcomeTimeslots(): Array<string> {
    let value = this.get("userOutcomeTimeslots");
    return value!.toStringArray();
  }

  set userOutcomeTimeslots(value: Array<string>) {
    this.set("userOutcomeTimeslots", Value.fromStringArray(value));
  }

  get userOutcomes(): Array<string> {
    let value = this.get("userOutcomes");
    return value!.toStringArray();
  }

  set userOutcomes(value: Array<string>) {
    this.set("userOutcomes", Value.fromStringArray(value));
  }

  get outcomeTimeslotTransfersTo(): Array<string> {
    let value = this.get("outcomeTimeslotTransfersTo");
    return value!.toStringArray();
  }

  set outcomeTimeslotTransfersTo(value: Array<string>) {
    this.set("outcomeTimeslotTransfersTo", Value.fromStringArray(value));
  }

  get outcomeTimeslotTransfersFrom(): Array<string> {
    let value = this.get("outcomeTimeslotTransfersFrom");
    return value!.toStringArray();
  }

  set outcomeTimeslotTransfersFrom(value: Array<string>) {
    this.set("outcomeTimeslotTransfersFrom", Value.fromStringArray(value));
  }

  get createdVirtualFloors(): Array<string> {
    let value = this.get("createdVirtualFloors");
    return value!.toStringArray();
  }

  set createdVirtualFloors(value: Array<string>) {
    this.set("createdVirtualFloors", Value.fromStringArray(value));
  }

  get ownedVirtualFloors(): Array<string> {
    let value = this.get("ownedVirtualFloors");
    return value!.toStringArray();
  }

  set ownedVirtualFloors(value: Array<string>) {
    this.set("ownedVirtualFloors", Value.fromStringArray(value));
  }

  get challengedVirtualFloors(): Array<string> {
    let value = this.get("challengedVirtualFloors");
    return value!.toStringArray();
  }

  set challengedVirtualFloors(value: Array<string>) {
    this.set("challengedVirtualFloors", Value.fromStringArray(value));
  }

  get roleUsers(): Array<string> {
    let value = this.get("roleUsers");
    return value!.toStringArray();
  }

  set roleUsers(value: Array<string>) {
    this.set("roleUsers", Value.fromStringArray(value));
  }

  get maxConcurrentVirtualFloors(): BigInt {
    let value = this.get("maxConcurrentVirtualFloors");
    return value!.toBigInt();
  }

  set maxConcurrentVirtualFloors(value: BigInt) {
    this.set("maxConcurrentVirtualFloors", Value.fromBigInt(value));
  }

  get concurrentVirtualFloors(): BigInt {
    let value = this.get("concurrentVirtualFloors");
    return value!.toBigInt();
  }

  set concurrentVirtualFloors(value: BigInt) {
    this.set("concurrentVirtualFloors", Value.fromBigInt(value));
  }
}

export class UserOutcome extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserOutcome entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserOutcome must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserOutcome", id.toString(), this);
    }
  }

  static load(id: string): UserOutcome | null {
    return changetype<UserOutcome | null>(store.get("UserOutcome", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get outcome(): string {
    let value = this.get("outcome");
    return value!.toString();
  }

  set outcome(value: string) {
    this.set("outcome", Value.fromString(value));
  }

  get userVirtualFloor(): string {
    let value = this.get("userVirtualFloor");
    return value!.toString();
  }

  set userVirtualFloor(value: string) {
    this.set("userVirtualFloor", Value.fromString(value));
  }

  get userOutcomeTimeslots(): Array<string> {
    let value = this.get("userOutcomeTimeslots");
    return value!.toStringArray();
  }

  set userOutcomeTimeslots(value: Array<string>) {
    this.set("userOutcomeTimeslots", Value.fromStringArray(value));
  }

  get totalBalance(): BigDecimal {
    let value = this.get("totalBalance");
    return value!.toBigDecimal();
  }

  set totalBalance(value: BigDecimal) {
    this.set("totalBalance", Value.fromBigDecimal(value));
  }

  get totalWeightedBalance(): BigDecimal {
    let value = this.get("totalWeightedBalance");
    return value!.toBigDecimal();
  }

  set totalWeightedBalance(value: BigDecimal) {
    this.set("totalWeightedBalance", Value.fromBigDecimal(value));
  }

  get totalClaimedBalance(): BigDecimal {
    let value = this.get("totalClaimedBalance");
    return value!.toBigDecimal();
  }

  set totalClaimedBalance(value: BigDecimal) {
    this.set("totalClaimedBalance", Value.fromBigDecimal(value));
  }

  get totalBalancePlusTotalClaimedBalance(): BigDecimal {
    let value = this.get("totalBalancePlusTotalClaimedBalance");
    return value!.toBigDecimal();
  }

  set totalBalancePlusTotalClaimedBalance(value: BigDecimal) {
    this.set(
      "totalBalancePlusTotalClaimedBalance",
      Value.fromBigDecimal(value)
    );
  }
}

export class OutcomeTimeslot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OutcomeTimeslot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OutcomeTimeslot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OutcomeTimeslot", id.toString(), this);
    }
  }

  static load(id: string): OutcomeTimeslot | null {
    return changetype<OutcomeTimeslot | null>(store.get("OutcomeTimeslot", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    return value!.toBigInt();
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get outcome(): string {
    let value = this.get("outcome");
    return value!.toString();
  }

  set outcome(value: string) {
    this.set("outcome", Value.fromString(value));
  }

  get timeslot(): BigInt {
    let value = this.get("timeslot");
    return value!.toBigInt();
  }

  set timeslot(value: BigInt) {
    this.set("timeslot", Value.fromBigInt(value));
  }

  get userOutcomeTimeslots(): Array<string> {
    let value = this.get("userOutcomeTimeslots");
    return value!.toStringArray();
  }

  set userOutcomeTimeslots(value: Array<string>) {
    this.set("userOutcomeTimeslots", Value.fromStringArray(value));
  }

  get outcomeTimeslotTransfers(): Array<string> {
    let value = this.get("outcomeTimeslotTransfers");
    return value!.toStringArray();
  }

  set outcomeTimeslotTransfers(value: Array<string>) {
    this.set("outcomeTimeslotTransfers", Value.fromStringArray(value));
  }

  get totalSupply(): BigDecimal {
    let value = this.get("totalSupply");
    return value!.toBigDecimal();
  }

  set totalSupply(value: BigDecimal) {
    this.set("totalSupply", Value.fromBigDecimal(value));
  }

  get beta(): BigDecimal {
    let value = this.get("beta");
    return value!.toBigDecimal();
  }

  set beta(value: BigDecimal) {
    this.set("beta", Value.fromBigDecimal(value));
  }
}

export class UserOutcomeTimeslot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserOutcomeTimeslot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserOutcomeTimeslot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserOutcomeTimeslot", id.toString(), this);
    }
  }

  static load(id: string): UserOutcomeTimeslot | null {
    return changetype<UserOutcomeTimeslot | null>(
      store.get("UserOutcomeTimeslot", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get outcome(): string {
    let value = this.get("outcome");
    return value!.toString();
  }

  set outcome(value: string) {
    this.set("outcome", Value.fromString(value));
  }

  get outcomeTimeslot(): string {
    let value = this.get("outcomeTimeslot");
    return value!.toString();
  }

  set outcomeTimeslot(value: string) {
    this.set("outcomeTimeslot", Value.fromString(value));
  }

  get userOutcome(): string {
    let value = this.get("userOutcome");
    return value!.toString();
  }

  set userOutcome(value: string) {
    this.set("userOutcome", Value.fromString(value));
  }

  get balance(): BigDecimal {
    let value = this.get("balance");
    return value!.toBigDecimal();
  }

  set balance(value: BigDecimal) {
    this.set("balance", Value.fromBigDecimal(value));
  }

  get claimedBalance(): BigDecimal {
    let value = this.get("claimedBalance");
    return value!.toBigDecimal();
  }

  set claimedBalance(value: BigDecimal) {
    this.set("claimedBalance", Value.fromBigDecimal(value));
  }

  get balancePlusClaimedBalance(): BigDecimal {
    let value = this.get("balancePlusClaimedBalance");
    return value!.toBigDecimal();
  }

  set balancePlusClaimedBalance(value: BigDecimal) {
    this.set("balancePlusClaimedBalance", Value.fromBigDecimal(value));
  }
}

export class OutcomeTimeslotTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OutcomeTimeslotTransfer entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OutcomeTimeslotTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OutcomeTimeslotTransfer", id.toString(), this);
    }
  }

  static load(id: string): OutcomeTimeslotTransfer | null {
    return changetype<OutcomeTimeslotTransfer | null>(
      store.get("OutcomeTimeslotTransfer", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get outcomeTimeslot(): string {
    let value = this.get("outcomeTimeslot");
    return value!.toString();
  }

  set outcomeTimeslot(value: string) {
    this.set("outcomeTimeslot", Value.fromString(value));
  }

  get from(): string {
    let value = this.get("from");
    return value!.toString();
  }

  set from(value: string) {
    this.set("from", Value.fromString(value));
  }

  get to(): string {
    let value = this.get("to");
    return value!.toString();
  }

  set to(value: string) {
    this.set("to", Value.fromString(value));
  }

  get txHash(): Bytes {
    let value = this.get("txHash");
    return value!.toBytes();
  }

  set txHash(value: Bytes) {
    this.set("txHash", Value.fromBytes(value));
  }

  get txTimestamp(): BigInt {
    let value = this.get("txTimestamp");
    return value!.toBigInt();
  }

  set txTimestamp(value: BigInt) {
    this.set("txTimestamp", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    return value!.toBigDecimal();
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }
}

export class PaymentToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PaymentToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PaymentToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PaymentToken", id.toString(), this);
    }
  }

  static load(id: string): PaymentToken | null {
    return changetype<PaymentToken | null>(store.get("PaymentToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    return value!.toI32();
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get isWhitelisted(): boolean {
    let value = this.get("isWhitelisted");
    return value!.toBoolean();
  }

  set isWhitelisted(value: boolean) {
    this.set("isWhitelisted", Value.fromBoolean(value));
  }

  get isTest(): boolean {
    let value = this.get("isTest");
    return value!.toBoolean();
  }

  set isTest(value: boolean) {
    this.set("isTest", Value.fromBoolean(value));
  }
}

export class VirtualFloorsAggregate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save VirtualFloorsAggregate entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VirtualFloorsAggregate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VirtualFloorsAggregate", id.toString(), this);
    }
  }

  static load(id: string): VirtualFloorsAggregate | null {
    return changetype<VirtualFloorsAggregate | null>(
      store.get("VirtualFloorsAggregate", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalVirtualFloorsCreated(): i32 {
    let value = this.get("totalVirtualFloorsCreated");
    return value!.toI32();
  }

  set totalVirtualFloorsCreated(value: i32) {
    this.set("totalVirtualFloorsCreated", Value.fromI32(value));
  }
}

export class UserVirtualFloor extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserVirtualFloor entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserVirtualFloor must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserVirtualFloor", id.toString(), this);
    }
  }

  static load(id: string): UserVirtualFloor | null {
    return changetype<UserVirtualFloor | null>(
      store.get("UserVirtualFloor", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get virtualFloor(): string {
    let value = this.get("virtualFloor");
    return value!.toString();
  }

  set virtualFloor(value: string) {
    this.set("virtualFloor", Value.fromString(value));
  }

  get userOutcomes(): Array<string> {
    let value = this.get("userOutcomes");
    return value!.toStringArray();
  }

  set userOutcomes(value: Array<string>) {
    this.set("userOutcomes", Value.fromStringArray(value));
  }

  get totalBalance(): BigDecimal {
    let value = this.get("totalBalance");
    return value!.toBigDecimal();
  }

  set totalBalance(value: BigDecimal) {
    this.set("totalBalance", Value.fromBigDecimal(value));
  }

  get totalClaimedBalance(): BigDecimal {
    let value = this.get("totalClaimedBalance");
    return value!.toBigDecimal();
  }

  set totalClaimedBalance(value: BigDecimal) {
    this.set("totalClaimedBalance", Value.fromBigDecimal(value));
  }

  get totalBalancePlusTotalClaimedBalance(): BigDecimal {
    let value = this.get("totalBalancePlusTotalClaimedBalance");
    return value!.toBigDecimal();
  }

  set totalBalancePlusTotalClaimedBalance(value: BigDecimal) {
    this.set(
      "totalBalancePlusTotalClaimedBalance",
      Value.fromBigDecimal(value)
    );
  }
}

export class Role extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Role entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Role must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Role", id.toString(), this);
    }
  }

  static load(id: string): Role | null {
    return changetype<Role | null>(store.get("Role", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get roleUsers(): Array<string> {
    let value = this.get("roleUsers");
    return value!.toStringArray();
  }

  set roleUsers(value: Array<string>) {
    this.set("roleUsers", Value.fromStringArray(value));
  }
}

export class RoleUser extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleUser entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleUser must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleUser", id.toString(), this);
    }
  }

  static load(id: string): RoleUser | null {
    return changetype<RoleUser | null>(store.get("RoleUser", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): string {
    let value = this.get("role");
    return value!.toString();
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    return value!.toString();
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }
}
